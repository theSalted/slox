//
// Expression.swift
//
//
// Generated by SyntaxDefinitionGenerator on 06/15/24
//


/*
 * Name like Expr and Stmt are abbreviations and is against
 * Swift's API Design Guidelines.
 */


public protocol Expression {
    func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn
}

public protocol ExpressionVisitor {
    associatedtype ExpressionVisitorReturn

    func visit(_ expr: Assignment) -> ExpressionVisitorReturn
    func visit(_ expr: Binary) -> ExpressionVisitorReturn
    func visit(_ expr: Grouping) -> ExpressionVisitorReturn
    func visit(_ expr: Literal) -> ExpressionVisitorReturn
    func visit(_ expr: Unary) -> ExpressionVisitorReturn
    func visit(_ expr: Variable) -> ExpressionVisitorReturn
}

public struct Assignment: Expression {
    let name: Token
    let value: Expression

    init(name: Token, value: Expression) {
        self.name = name
        self.value = value
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public struct Binary: Expression {
    let lhs: Expression
    let `operator`: Token
    let rhs: Expression

    init(lhs: Expression, `operator`: Token, rhs: Expression) {
        self.lhs = lhs
        self.`operator` = `operator`
        self.rhs = rhs
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public struct Grouping: Expression {
    let expression: Expression

    init(expression: Expression) {
        self.expression = expression
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public struct Literal: Expression {
    let value: Any?

    init(value: Any?) {
        self.value = value
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public struct Unary: Expression {
    let `operator`: Token
    let rhs: Expression

    init(`operator`: Token, rhs: Expression) {
        self.`operator` = `operator`
        self.rhs = rhs
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public struct Variable: Expression {
    let name: Token

    init(name: Token) {
        self.name = name
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

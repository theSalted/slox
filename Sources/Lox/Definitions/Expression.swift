//
// Expression.swift
//
//
// Generated by SyntaxDefinitionGenerator on 07/20/24
//


public protocol Expression: AnyObject {
    func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn
}

public protocol ExpressionVisitor {
    associatedtype ExpressionVisitorReturn

    func visit(_ expr: Assignment) -> ExpressionVisitorReturn
    func visit(_ expr: Binary) -> ExpressionVisitorReturn
    func visit(_ expr: Call) -> ExpressionVisitorReturn
    func visit(_ expr: Get) -> ExpressionVisitorReturn
    func visit(_ expr: Grouping) -> ExpressionVisitorReturn
    func visit(_ expr: Literal) -> ExpressionVisitorReturn
    func visit(_ expr: Logical) -> ExpressionVisitorReturn
    func visit(_ expr: Unary) -> ExpressionVisitorReturn
    func visit(_ expr: Variable) -> ExpressionVisitorReturn
}

public final class Assignment: Expression {
    let name: Token
    let value: Expression

    init(name: Token, value: Expression) {
        self.name = name
        self.value = value
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public final class Binary: Expression {
    let lhs: Expression
    let `operator`: Token
    let rhs: Expression

    init(lhs: Expression, `operator`: Token, rhs: Expression) {
        self.lhs = lhs
        self.`operator` = `operator`
        self.rhs = rhs
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public final class Call: Expression {
    let callee: Expression
    let paren: Token
    let arguments: Array<Expression>

    init(callee: Expression, paren: Token, arguments: Array<Expression>) {
        self.callee = callee
        self.paren = paren
        self.arguments = arguments
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public final class Get: Expression {
    let object: Expression
    let name: Token

    init(object: Expression, name: Token) {
        self.object = object
        self.name = name
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public final class Grouping: Expression {
    let expression: Expression

    init(expression: Expression) {
        self.expression = expression
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public final class Literal: Expression {
    let value: Any?

    init(value: Any?) {
        self.value = value
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public final class Logical: Expression {
    let lhs: Expression
    let `operator`: Token
    let rhs: Expression

    init(lhs: Expression, `operator`: Token, rhs: Expression) {
        self.lhs = lhs
        self.`operator` = `operator`
        self.rhs = rhs
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public final class Unary: Expression {
    let `operator`: Token
    let rhs: Expression

    init(`operator`: Token, rhs: Expression) {
        self.`operator` = `operator`
        self.rhs = rhs
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}

public final class Variable: Expression {
    let name: Token

    init(name: Token) {
        self.name = name
    }

    public func accept<V: ExpressionVisitor, R>(visitor: V) -> R where R == V.ExpressionVisitorReturn {
        return visitor.visit(self)
    }
}
